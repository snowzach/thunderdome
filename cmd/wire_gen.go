// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package cmd

import (
	"context"
	"crypto/tls"
	"git.coinninja.net/backend/thunderdome/rpcserver"
	"git.coinninja.net/backend/thunderdome/server"
	"git.coinninja.net/backend/thunderdome/store/postgres"
	"git.coinninja.net/backend/thunderdome/thunderdome"
	"git.coinninja.net/backend/thunderdome/txmonitor"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/rpcclient"
	"github.com/lightningnetwork/lnd/lnrpc"
	"github.com/lightningnetwork/lnd/macaroons"
	"github.com/spf13/viper"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/status"
	"gopkg.in/macaroon.v2"
	"io/ioutil"
	"net"
	"time"
)

import (
	_ "net/http/pprof"
)

// Injectors from wire.go:

func NewServer() (*server.Server, error) {
	serverServer, err := server.New()
	if err != nil {
		return nil, err
	}
	return serverServer, nil
}

func NewRPCServer() (*rpcserver.RPCServer, error) {
	store := NewStore()
	clientConn := NewLndGrpcClientConn()
	lightningClient := NewLightningClient(clientConn)
	rpcServer, err := rpcserver.NewRPCServer(store, lightningClient)
	if err != nil {
		return nil, err
	}
	return rpcServer, nil
}

func NewTXMonitor() (*txmonitor.TXMonitor, error) {
	store := NewStore()
	clientConn := NewLndGrpcClientConn()
	client := NewBTCRPCClient()
	params := NewChainParams(client)
	txMonitor, err := txmonitor.NewTXMonitor(store, clientConn, client, params)
	if err != nil {
		return nil, err
	}
	return txMonitor, nil
}

// wire.go:

// NewStore is the store for the application
func NewStore() thunderdome.Store {
	var store thunderdome.Store
	var err error
	switch viper.GetString("storage.type") {
	case "postgres":
		store, err = postgres.New()
	}
	if err != nil {
		logger.Fatalw("Database Error", "error", err)
	}
	return store
}

func NewBTCRPCClient() *rpcclient.Client {

	rpcc, err := rpcclient.New(&rpcclient.ConnConfig{
		HTTPPostMode: viper.GetBool("btc.post_mode"),
		DisableTLS:   viper.GetBool("btc.disable_tls"),
		Host:         net.JoinHostPort(viper.GetString("btc.host"), viper.GetString("btc.port")),
		User:         viper.GetString("btc.username"),
		Pass:         viper.GetString("btc.password"),
	}, nil)
	if err != nil {
		logger.Fatalf("error creating new btc client: %v", err)
	}

	_, err = rpcc.GetBlockChainInfo()
	if err != nil {
		logger.Fatalf("Could not GetBlockChainInfo from BTC RPC Server %v", err)
	}

	return rpcc

}

func NewChainParams(rpcc *rpcclient.Client) *chaincfg.Params {

	// Create an array of chains such that we can pick the one we want
	var chain *chaincfg.Params
	chains := []*chaincfg.Params{
		&chaincfg.MainNetParams,
		&chaincfg.RegressionNetParams,
		&chaincfg.SimNetParams,
		&chaincfg.TestNet3Params,
	}

	for _, cp := range chains {
		if viper.GetString("btc.chain") == cp.Name {
			chain = cp
			break
		}
	}
	if chain == nil {
		logger.Fatalf("Could not find chain %s", viper.GetString("btc.chain"))
	}

	blockChainInfo, err := rpcc.GetBlockChainInfo()
	if err != nil {
		logger.Fatalf("Could not GetBlockChainInfo from BTC RPC Server %v", err)
	}

	if blockChainInfo.Chain != chain.Name {
		logger.Fatalf("Chain mismatch rpc:%s config:%s", blockChainInfo.Chain, chain.Name)
	}

	return chain

}

func NewLightningClient(conn *grpc.ClientConn) lnrpc.LightningClient {

	_, err := lnrpc.NewWalletUnlockerClient(conn).UnlockWallet(context.Background(), &lnrpc.UnlockWalletRequest{
		WalletPassword: []byte(viper.GetString("lnd.unlock_password")),
	})
	if err == nil {
		logger.Info("Wallet Unlocked")

		conn.Close()
		conn = NewLndGrpcClientConn()
	} else if status.Code(err) == codes.Unimplemented {
		logger.Info("Wallet Already Unlocked")
	} else {
		logger.Fatalf("Could not UnlockWallet: %v", err)
	}

	return lnrpc.NewLightningClient(conn)
}

// NewLndGrpcClientConn creates a new GRPC connection to LND
func NewLndGrpcClientConn() *grpc.ClientConn {

	dialOptions := []grpc.DialOption{grpc.WithTimeout(10 * time.Second), grpc.WithBlock()}

	if viper.GetBool("lnd.tls_insecure") {
		creds := credentials.NewTLS(&tls.Config{
			InsecureSkipVerify: true,
		})
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(creds))
	} else {

		creds, err := credentials.NewClientTLSFromFile(viper.GetString("lnd.tls_cert"), viper.GetString("lnd.tls_host"))
		if err != nil {
			logger.Fatalw("Could not load credentials", "error", err)
		}
		dialOptions = append(dialOptions, grpc.WithTransportCredentials(creds))
	}

	macBytes, err := ioutil.ReadFile(viper.GetString("lnd.macaroon"))
	if err != nil {
		logger.Fatalw("Unable to read macaroon", "error", err)
	}

	mac := &macaroon.Macaroon{}
	if err = mac.UnmarshalBinary(macBytes); err != nil {
		logger.Fatalw("Unable to decode macaroon", "error", err)
	}

	cred := macaroons.NewMacaroonCredential(mac)
	dialOptions = append(dialOptions, grpc.WithPerRPCCredentials(cred))

	conn, err := grpc.Dial(net.JoinHostPort(viper.GetString("lnd.host"), viper.GetString("lnd.port")), dialOptions...)
	if err != nil {
		logger.Fatalw("Could not connect to lnd", "error", err, "host:port", net.JoinHostPort(viper.GetString("lnd.host"), viper.GetString("lnd.port")))
	}

	return conn

}
